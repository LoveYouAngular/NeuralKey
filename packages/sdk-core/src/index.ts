import init, { generate_zkp } from '@neuralkey/zkp-prover'; // Import init and generate_zkp
import { HDNodeWallet, Mnemonic } from 'ethers';

// Flag to ensure Wasm is initialized only once
let wasmInitialized = false;

/**
 * @notice Defines the function signature for a ZKP generator.
 */
export type ZkpGenerator = (private_input: Uint8Array, public_input: Uint8Array) => Uint8Array;


/**
 * @notice Specific data for a keyboard event.
 */
export interface KeyEventData {
  key: string;
  direction: 'up' | 'down';
  pressure?: number; // Optional: For devices that support it
}

/**
 * @notice Specific data for a mouse movement event.
 */
export interface MouseEventData {
  x: number;
  y: number;
  dx: number;
  dy: number;
}

/**
 * @notice Specific data for a device motion/orientation event.
 */
export interface MotionEventData {
  alpha: number; // z-axis rotation
  beta: number;  // x-axis rotation
  gamma: number; // y-axis rotation
}

/**
 * @notice A discriminated union representing a single interaction event from a device sensor.
 * @dev This provides a structured way to handle different types of sensor input.
 */
export type InteractionEvent =
  | { type: 'key'; timestamp: number; data: KeyEventData }
  | { type: 'mouse'; timestamp: number; data: MouseEventData }
  | { type: 'motion'; timestamp: number; data: MotionEventData };


/**
 * @notice A cryptographic proof generated by the user's device.
 * @dev This proof is a zero-knowledge proof that attests to the user's
 * identity without revealing the raw behavioral data.
 */
export interface ZeroKnowledgeProof {
  proof: Uint8Array;
  publicSignals: Uint8Array;
}

/**
 * @notice The core interface for the client-side of the Neural Key handshake protocol.
 */
export interface NeuralClient {
  /**
   * @notice Initiates a request for identity verification to the user's device.
   * @param challenge A unique, single-use challenge string to prevent replay attacks.
   * @returns A promise that resolves with a ZeroKnowledgeProof from the client.
   */
  requestVerification(challenge: string): Promise<ZeroKnowledgeProof>;
}

/**
 * @notice The core interface for the server-side (relying party) of the Neural Key handshake protocol.
 */
export interface NeuralVerifier {
  /**
   * @notice Validates a ZeroKnowledgeProof against a given challenge.
   * @dev This method would be called by a relying party (e.g., a web server)
   * to authenticate the user. The implementation will verify the proof
   * without access to any private user data.
   * @param proof The ZeroKnowledgeProof received from the user's device.
   * @param originalChallenge The original challenge sent to the device.
   * @returns A promise that resolves to a boolean indicating if the proof is valid.
   */
  validateProof(proof: ZeroKnowledgeProof, originalChallenge: string): Promise<boolean>;
}

/**
 * Implements the NeuralClient interface for client-side operations.
 */
export class NeuralHandshakeClient implements NeuralClient {
    private constructor(private readonly wallet: HDNodeWallet) {}

    public static async create(): Promise<NeuralHandshakeClient> {
        // Initialize WASM module if not already initialized
        if (!wasmInitialized) {
            // The path to the .wasm file relative to the served Angular app.
            // This assumes the 'pkg' directory of zkp-prover is copied to the Angular app's assets.
            // We will need to ensure this copying happens in the Angular build process.
            await init('/assets/zkp_prover_bg.wasm'); // Assuming the .wasm file will be in /assets
            wasmInitialized = true;
        }

        const phrase = globalThis.localStorage.getItem("NEURAL_KEY_MNEMONIC");
        if (phrase) {
            try {
                const mnemonic = Mnemonic.fromPhrase(phrase);
                const wallet = HDNodeWallet.fromMnemonic(mnemonic);
                return new NeuralHandshakeClient(wallet);
            } catch (error) {
                // The stored mnemonic is invalid, so we clear it.
                globalThis.localStorage.removeItem("NEURAL_KEY_MNEMONIC");
            }
        }

        // If there was no phrase or it was invalid, create a new wallet.
        const wallet = HDNodeWallet.createRandom();
        if (wallet.mnemonic) {
            globalThis.localStorage.setItem("NEURAL_KEY_MNEMONIC", wallet.mnemonic.phrase);
        }
        return new NeuralHandshakeClient(wallet);
    }

    public async requestVerification(challenge: string): Promise<ZeroKnowledgeProof> {
        // 1. Sign the challenge to prove ownership of the key.
        const signature = await this.wallet.signMessage(challenge);
        const encoder = new TextEncoder();

        // 2. Generate the Zero-Knowledge Proof using the WASM module.
        const proof = generate_zkp(
          encoder.encode(signature),
          encoder.encode(challenge)
        );

        return {
            proof: proof,
            publicSignals: encoder.encode(challenge)
        };
    }
}

export * from './recovery.js';
