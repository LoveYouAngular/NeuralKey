import { HDNodeWallet, Mnemonic } from 'ethers';

// Declare wasm_bindgen globally for TypeScript
declare const wasm_bindgen: any;

// Flag to ensure Wasm is initialized only once
let wasmInitialized = false;

// Promise to ensure the script is loaded only once
let scriptLoadPromise: Promise<void> | null = null;

function loadWasmScript(): Promise<void> {
  if (scriptLoadPromise) {
    return scriptLoadPromise;
  }

  scriptLoadPromise = new Promise((resolve, reject) => {
    // Check if the script already exists on the document
    if (typeof document !== 'undefined' && document.querySelector('script[src="/zkp_prover.js"]')) {
      return resolve();
    }

    const script = document.createElement('script');
    script.src = '/zkp_prover.js';
    script.async = true;
    script.onload = () => resolve();
    script.onerror = (err) => reject(new Error(`Failed to load WASM script: ${err.toString()}`));
    document.head.appendChild(script);
  });

  return scriptLoadPromise;
}


/**
 * @notice Defines the function signature for a ZKP generator.
 */
export type ZkpGenerator = (private_input: Uint8Array, public_input: Uint8Array) => Uint8Array;


/**
 * @notice Specific data for a keyboard event.
 */
export interface KeyEventData {
  key: string;
  direction: 'up' | 'down';
  pressure?: number; // Optional: For devices that support it
}

/**
 * @notice Specific data for a mouse movement event.
 */
export interface MouseEventData {
  x: number;
  y: number;
  dx: number;
  dy: number;
}

/**
 * @notice Specific data for a device motion/orientation event.
 */
export interface MotionEventData {
  alpha: number; // z-axis rotation
  beta: number;  // x-axis rotation
  gamma: number; // y-axis rotation
}

/**
 * @notice A discriminated union representing a single interaction event from a device sensor.
 * @dev This provides a structured way to handle different types of sensor input.
 */
export type InteractionEvent =
  | { type: 'key'; timestamp: number; data: KeyEventData }
  | { type: 'mouse'; timestamp: number; data: MouseEventData }
  | { type: 'motion'; timestamp: number; data: MotionEventData };


/**
 * @notice A cryptographic proof generated by the user's device.
 * @dev This proof is a zero-knowledge proof that attests to the user's
 * identity without revealing the raw behavioral data.
 */
export interface ZeroKnowledgeProof {
  proof: Uint8Array;
  publicSignals: Uint8Array;
}

/**
 * @notice The core interface for the client-side of the Neural Key handshake protocol.
 */
export interface NeuralClient {
  /**
   * @notice Initiates a request for identity verification to the user's device.
   * @param challenge A unique, single-use challenge string to prevent replay attacks.
   * @returns A promise that resolves with a ZeroKnowledgeProof from the client.
   */
  requestVerification(challenge: string): Promise<ZeroKnowledgeProof>;
}

/**
 * @notice The core interface for the server-side (relying party) of the Neural Key handshake protocol.
 */
export interface NeuralVerifier {
  /**
   * @notice Validates a ZeroKnowledgeProof against a given challenge.
   * @dev This method would be called by a relying party (e.g., a web server)
   * to authenticate the user. The implementation will verify the proof
   * without access to any private user data.
   * @param proof The ZeroKnowledgeProof received from the user's device.
   * @param originalChallenge The original challenge sent to the device.
   * @returns A promise that resolves to a boolean indicating if the proof is valid.
   */
  validateProof(proof: ZeroKnowledgeProof, originalChallenge: string): Promise<boolean>;
}

/**
 * Implements the NeuralClient interface for client-side operations.
 */
export class NeuralHandshakeClient implements NeuralClient {
    private constructor(private readonly wallet: HDNodeWallet) {}

    public static async create(): Promise<NeuralHandshakeClient> {
        // Initialize WASM module if not already initialized
        if (!wasmInitialized) {
            await loadWasmScript();
            await wasm_bindgen('/zkp_prover_bg.wasm');
            wasmInitialized = true;
        }

        const phrase = globalThis.localStorage.getItem("NEURAL_KEY_MNEMONIC");
        if (phrase) {
            try {
                const mnemonic = Mnemonic.fromPhrase(phrase);
                const wallet = HDNodeWallet.fromMnemonic(mnemonic);
                return new NeuralHandshakeClient(wallet);
            } catch (error) {
                // The stored mnemonic is invalid, so we clear it.
                globalThis.localStorage.removeItem("NEURAL_KEY_MNEMONIC");
            }
        }

        // If there was no phrase or it was invalid, create a new wallet.
        const wallet = HDNodeWallet.createRandom();
        if (wallet.mnemonic) {
            globalThis.localStorage.setItem("NEURAL_KEY_MNEMONIC", wallet.mnemonic.phrase);
        }
        return new NeuralHandshakeClient(wallet);
    }

    public async requestVerification(challenge: string): Promise<ZeroKnowledgeProof> {
        // 1. Sign the challenge to prove ownership of the key.
        const signature = await this.wallet.signMessage(challenge);
        const encoder = new TextEncoder();

        // 2. Generate the Zero-Knowledge Proof using the WASM module.
        const proof = wasm_bindgen.generate_zkp(
          encoder.encode(signature),
          encoder.encode(challenge)
        );

        return {
            proof: proof,
            publicSignals: encoder.encode(challenge)
        };
    }
}

export * from './recovery.js';

// Re-export necessary types from ethers for convenience
export {
    Mnemonic,
    HDNodeWallet,
    Wallet,
    JsonRpcProvider,
    BrowserProvider,
    AbstractProvider,
    FallbackProvider,
    WebSocketProvider,
    isError,
    computeAddress,
    resolveAddress,
    getAddress,
    getIcapAddress,
    getCreateAddress,
    getCreate2Address,
    ZeroAddress,
    isAddress,
    isAddressable,
    isHexString,
    isBytesLike,
    isBytes,
    isBigInt,
    isCallException,
    isQuorum,
    assert,
    assertArgument,
    assertPrivate,
    assertInteger,
    assertSafeInteger,
    defineProperties,
    EventPayload,
    resolveProperties,
    getBigInt,
    getNumber,
    getBytes,
    hexlify,
    toUtf8Bytes,
    toUtf8String,
    concat,
    dataLength,
    stripZerosLeft,
    zeroPadValue,
    zeroPadBytes,
    encodeBase58,
    decodeBase58,
    encodeBase64,
    decodeBase64,
    encodeBytes32String,
    decodeBytes32String,
    id,
    keccak256,
    ripemd160,
    sha256,
    sha512,
    pbkdf2,
    scrypt,
    scryptSync,
    computeHmac,
    Signature,
    SigningKey,
    verifyMessage,
    verifyTypedData,
    hashMessage,
    solidityPacked,
    solidityPackedKeccak256,
    solidityPackedSha256,
    TypedDataEncoder,
    AbiCoder,
    ParamType,
    checkResult,
    formatEther,
    parseEther,
    formatUnits,
    parseUnits,
    FetchRequest,
    FixedNumber,
    WeiPerEther,
    MaxUint256,
    MinInt256,
    MaxInt256,
    N,
    WordSize,
    randomBytes,
    shuffled,
    concatMap,
    defineReadOnly,
    getNetwork,
    isCommunityResource,
    isPromise,
    makeError,
    resolve,
    Frozen,
    Observable,
    Typed,
    fromTwos,
    toTwos,
    mask,
    getUint,
    setBit,
    getBit,
    toQuantity,
    toBeHex,
    toBeArray,
    decodeRlp,
    encodeRlp,
    accessListify,
    computeAlias,
    isAccessList,
    isAccessListish,
    Transaction,
    FeeData,
    Log,
    Block,
    TransactionReceipt,
    TransactionResponse,
    Contract,
    ContractFactory,
    ContractEventPayload,
    ContractUnknownEventPayload,
    ContractTransactionResponse,
    ContractTransactionReceipt,
    ContractDeployTransaction,
    copyRequest,
    populateTransaction,
    getPlugin,
    getProvider,
    getAccount,
    getRpcError,
    EthersError,
    UnknownError,
    NotImplementedError,
    MissingArgumentError,
    InvalidArgumentError,
    BadArgumentError,
    BufferOverrunError,
    NumericFaultError,
    UnsupportedOperationError,
    NetworkError,
    BadDataError,
    ServerError,
    TimeoutError,
    CallExceptionError,
    InsufficientFundsError,
    NonceExpiredError,
    ReplacementUnderpricedError,
    TransactionReplacedError,
    ActionRejectedError,
    UnconfiguredNameError,
    OffchainFaultError,
    EnsStaleAuthError,
    UnsafeDataError,
    InvalidAddressError,
    InvalidHexletError,
    InvalidHexStringError,

} from 'ethers';
